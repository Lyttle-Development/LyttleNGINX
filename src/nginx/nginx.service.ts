import { Injectable } from '@nestjs/common';
import { ProxyEntry, ProxyType } from '@prisma/client';
import * as fs from 'fs';

@Injectable()
export class NginxService {
  public generateNginxConfig(entries: ProxyEntry[]): string {
    let config = `# Generated by NestJS App - DO NOT EDIT`;

    for (const entry of entries) {
      const domains = entry.domains
        // Split domains by semicolon
        .split(';')
        // Remove whitespace and leading asterisk
        .map((d) => d.trim())
        // Remove newlines
        .map((d) => d.replace(/^\*/, '').trim())
        // Filter out empty domains
        .filter(Boolean);
      if (domains.length === 0) continue;
      const primaryDomain = domains[0];

      // Check if cert files exist
      const certPath = `/etc/letsencrypt/live/${primaryDomain}/fullchain.pem`;
      const keyPath = `/etc/letsencrypt/live/${primaryDomain}/privkey.pem`;
      const hasCert = fs.existsSync(certPath) && fs.existsSync(keyPath);

      const sslLines = hasCert
        ? `
  listen 443 ssl;
  listen [::]:443 ssl;
  ssl_certificate ${certPath};
  ssl_certificate_key ${keyPath};
      `
        : '';

      const server_block = `
server {
  listen 80;
  listen [::]:80;
  ${sslLines}
  server_name ${domains.join(' ')};

  ${
    entry.type === ProxyType.REDIRECT
      ? `return 301 ${entry.proxy_pass_host};`
      : `
  location / {
    proxy_pass ${entry.proxy_pass_host};
    proxy_ssl_verify off;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 86400;
  }
      `
  }
  ${entry.nginx_custom_code || ''}
}
`;
      config += server_block;
    }

    return config;
  }
}
