import { Injectable } from '@nestjs/common';
import { ProxyEntry, ProxyType } from '@prisma/client';
import * as fs from 'fs';

@Injectable()
export class NginxService {
  public generateNginxConfig(entries: ProxyEntry[], resolved: boolean): string {
    let config = `# Generated by Lyttle NGINX - DO NOT EDIT\n`;

    for (const entry of entries) {
      try {
        const domains = entry.domains
          .split(';')
          .map((d) => d.trim())
          .map((d) => d.replace(/^\*/, '').trim())
          .filter(Boolean);
        if (domains.length === 0) continue;
        const primaryDomain = domains[0];

        const certPath = `/etc/letsencrypt/live/${primaryDomain}/fullchain.pem`;
        const keyPath = `/etc/letsencrypt/live/${primaryDomain}/privkey.pem`;
        const hasCert = fs.existsSync(certPath) && fs.existsSync(keyPath);

        const sslLines =
          hasCert && entry.ssl
            ? `
  listen 443 ssl;
  listen [::]:443 ssl;
  ssl_certificate ${certPath};
  ssl_certificate_key ${keyPath};
      `
            : '';

        const server_block = `
server {
  listen 80;
  listen [::]:80;
  ${sslLines}
  server_name ${domains.join(' ')};

  ${
          entry.type === ProxyType.REDIRECT
            ? `return 301 ${entry.proxy_pass_host};`
            : `
  location / {
    ${resolved
              ? `proxy_pass ${entry.proxy_pass_host};`
              : 'return 503;'
            }
    proxy_ssl_verify off;

    proxy_pass_request_headers on;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host  $host;
    proxy_set_header X-Forwarded-Port  $server_port;
    proxy_set_header Forwarded         "for=$remote_addr;proto=$scheme;host=$host";

    proxy_set_header CF-Connecting-IP  $http_cf_connecting_ip;
    proxy_set_header CF-IPCountry      $http_cf_ipcountry;
    proxy_set_header CF-Ray            $http_cf_ray;
    proxy_set_header CF-Visitor        $http_cf_visitor;
    proxy_set_header True-Client-IP    $http_true_client_ip;

    proxy_http_version 1.1;
    proxy_set_header Upgrade           $http_upgrade;
    proxy_set_header Connection        $connection_upgrade;

    proxy_read_timeout 86400;
  }
      `
        }

  # Ensure upstream 5xx are intercepted so error_page is used
  proxy_intercept_errors on;

  # Custom error pages for 5xx responses.
  error_page 500 /error-5xx.html;
  location = /error-5xx.html {
      internal;
      root /etc/nginx/html/errors;
      try_files /5xx.html =502;
  }

  error_page 503 /error-broken.html;
  location = /error-broken.html {
      internal;
      root /etc/nginx/html/errors;
      try_files /broken.html =502;
  }

  error_page 502 504 /error-loading.html;
  location = /error-loading.html {
      internal;
      root /etc/nginx/html/errors;
      try_files /loading.html =502;
  }
  
  ${entry.nginx_custom_code || ''}
}
`;
        config += server_block;
      } catch (error) {
        console.error(`Error generating config for entry ${entry.id}:`, error);
      }
    }

    return config;
  }
}