import { Injectable } from '@nestjs/common';
import { ProxyEntry, ProxyType } from '@prisma/client';
import * as fs from 'fs';

@Injectable()
export class NginxService {
  public generateNginxConfig(entries: ProxyEntry[]): string {
    let config = `# Generated by NestJS App - DO NOT EDIT\n`;

    for (const entry of entries) {
      try {
        const domains = entry.domains
          // Split domains by semicolon
          .split(';')
          // Remove whitespace and leading asterisk
          .map((d) => d.trim())
          // Remove newlines
          .map((d) => d.replace(/^\*/, '').trim())
          // Filter out empty domains
          .filter(Boolean);
        if (domains.length === 0) continue;
        const primaryDomain = domains[0];

        // Check if cert files exist
        const certPath = `/etc/letsencrypt/live/${primaryDomain}/fullchain.pem`;
        const keyPath = `/etc/letsencrypt/live/${primaryDomain}/privkey.pem`;
        const hasCert = fs.existsSync(certPath) && fs.existsSync(keyPath);

        // If SSL is enabled and cert exists, create separate blocks for HTTP and HTTPS
        if (hasCert && entry.ssl) {
          // HTTP block - redirect to HTTPS
          config += `
# HTTP to HTTPS redirect for ${primaryDomain}
server {
  listen 80;
  listen [::]:80;
  server_name ${domains.join(' ')};

  # Allow ACME challenge for Let's Encrypt
  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
  }

  # Redirect all other traffic to HTTPS
  location / {
    return 301 https://$host$request_uri;
  }
}
`;

          // HTTPS block - main configuration
          const proxyConfig =
            entry.type === ProxyType.REDIRECT
              ? `  return 301 ${entry.proxy_pass_host};`
              : `
  location / {
    proxy_pass ${entry.proxy_pass_host};
    proxy_ssl_verify off;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 86400;
    
    # Additional security headers
    proxy_set_header X-Forwarded-Ssl on;
  }`;

          config += `
# HTTPS server for ${primaryDomain}
server {
  listen 443 ssl http2;
  listen [::]:443 ssl http2;
  server_name ${domains.join(' ')};

  # SSL Certificate
  ssl_certificate ${certPath};
  ssl_certificate_key ${keyPath};

  # HSTS (optional but recommended for production)
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

  # Additional security headers
  add_header X-Frame-Options "SAMEORIGIN" always;
  add_header X-Content-Type-Options "nosniff" always;
  add_header X-XSS-Protection "1; mode=block" always;

${proxyConfig}

  ${entry.nginx_custom_code || ''}
}
`;
        } else {
          // No SSL or cert not available - HTTP only
          const proxyConfig =
            entry.type === ProxyType.REDIRECT
              ? `  return 301 ${entry.proxy_pass_host};`
              : `
  location / {
    proxy_pass ${entry.proxy_pass_host};
    proxy_ssl_verify off;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 86400;
  }`;

          config += `
# HTTP-only server for ${primaryDomain}
server {
  listen 80;
  listen [::]:80;
  server_name ${domains.join(' ')};

  # Allow ACME challenge for Let's Encrypt
  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
  }

${proxyConfig}

  ${entry.nginx_custom_code || ''}
}
`;
        }
      } catch (error) {
        console.error(`Error generating config for entry ${entry.id}:`, error);
      }
    }

    return config;
  }
}
